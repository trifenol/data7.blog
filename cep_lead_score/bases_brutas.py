# -*- coding: utf-8 -*-
"""bases_brutas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dPvPFkCn4vZiwo620bgiCKkiI7QmXTcF
"""

# -*- coding: utf-8 -*-
"""
Gerador de Dados Sintéticos para Lead Scoring de Intercâmbio

Este script gera três bases simuladas:
- interesse.csv: leads que demonstraram interesse
- formulario.csv: subset que respondeu formulário de qualificação
- compras.csv: leads que converteram

A relação CEP → Renda → Conversão é propositalmente forte para
demonstrar o funcionamento do modelo de lead scoring.
"""

import numpy as np
import pandas as pd
import random
from datetime import datetime, timedelta

np.random.seed(42)
random.seed(42)

# ============================================================
# CONFIGURAÇÃO
# ============================================================
N_INTERESSE_ANO = 60000
PROP_FORMULARIO = 0.25
BASE_PROB_COMPRA = 0.01      # renda 1 = ~1% conversão
BONUS_PROB_COMPRA = 0.08     # renda 5 = ~9% conversão

DESTINOS = ["Canadá", "EUA", "Austrália", "Irlanda", "Reino Unido"]
PESOS_DESTINOS = [0.30, 0.25, 0.15, 0.20, 0.10]

# Regiões com diferenças mais pronunciadas de renda
# std reduzido para aumentar poder preditivo do CEP
REGIOES = [
    {"cep2": "01", "peso": 3.0, "media_renda": 4.6, "std_renda": 0.35},  # SP Jardins/Pinheiros
    {"cep2": "04", "peso": 2.0, "media_renda": 4.3, "std_renda": 0.40},  # SP Moema/Itaim
    {"cep2": "05", "peso": 1.5, "media_renda": 3.8, "std_renda": 0.45},  # SP Zona Oeste
    {"cep2": "22", "peso": 2.0, "media_renda": 4.4, "std_renda": 0.38},  # RJ Zona Sul
    {"cep2": "20", "peso": 1.0, "media_renda": 3.2, "std_renda": 0.50},  # RJ Centro/Norte
    {"cep2": "30", "peso": 1.5, "media_renda": 3.5, "std_renda": 0.45},  # BH
    {"cep2": "70", "peso": 1.0, "media_renda": 3.8, "std_renda": 0.45},  # Brasília
    {"cep2": "80", "peso": 1.2, "media_renda": 3.6, "std_renda": 0.45},  # Curitiba
    {"cep2": "90", "peso": 1.0, "media_renda": 3.4, "std_renda": 0.48},  # Porto Alegre
    {"cep2": "40", "peso": 0.8, "media_renda": 2.6, "std_renda": 0.50},  # Salvador
    {"cep2": "50", "peso": 0.6, "media_renda": 2.4, "std_renda": 0.50},  # Recife
    {"cep2": "60", "peso": 0.5, "media_renda": 2.3, "std_renda": 0.50},  # Fortaleza
]


# ============================================================
# FUNÇÕES AUXILIARES
# ============================================================

def gerar_cpf():
    return "".join(str(random.randint(0, 9)) for _ in range(11))


def gerar_email(cpf):
    dominios = ["gmail.com", "hotmail.com", "outlook.com", "yahoo.com.br"]
    return f"user{cpf[-6:]}@{random.choice(dominios)}"


def gerar_data_range(ano):
    inicio = datetime(ano, 1, 1)
    fim = datetime(ano, 12, 31)
    return inicio + timedelta(days=random.randint(0, (fim - inicio).days))


def gerar_cep(cep2):
    """Gera CEP de 8 dígitos mantendo o prefixo da região."""
    cep5 = cep2 + f"{random.randint(0, 999):03d}"
    cep8 = cep5 + f"{random.randint(0, 999):03d}"
    return cep8


def renda_para_texto(r):
    mapa = {
        1: "-R$2.000",
        2: "R$2.000–4.000",
        3: "R$4.000–8.000",
        4: "R$8.000–12.000",
        5: "+R$12.000"
    }
    return mapa.get(r, "R$4.000–8.000")


# ============================================================
# 1. BASE DE INTERESSE
# ============================================================

def gerar_interesse(ano):
    pesos = np.array([r["peso"] for r in REGIOES])
    pesos = pesos / pesos.sum()

    regioes_sorteadas = np.random.choice(REGIOES, size=N_INTERESSE_ANO, p=pesos)

    registros = []
    for regiao in regioes_sorteadas:
        cpf = gerar_cpf()
        registros.append({
            "data_interesse": gerar_data_range(ano),
            "cpf": cpf,
            "email": gerar_email(cpf),
            "cep": gerar_cep(regiao["cep2"]),
            "_media_renda": regiao["media_renda"],
            "_std_renda": regiao["std_renda"]
        })

    return pd.DataFrame(registros)


print("Gerando base de interesse...")
df_interesse = pd.concat([
    gerar_interesse(2024),
    gerar_interesse(2025)
], ignore_index=True)

print(f"  Total: {len(df_interesse):,} leads")


# ============================================================
# 2. BASE DE FORMULÁRIO (25% dos interessados)
# ============================================================

print("Gerando base de formulário...")
n_form = int(len(df_interesse) * PROP_FORMULARIO)
idx_form = np.random.choice(df_interesse.index, size=n_form, replace=False)

df_form_base = df_interesse.loc[idx_form].copy()

# Gerar renda com base na região
rendas_num = []
for _, row in df_form_base.iterrows():
    renda = np.random.normal(row["_media_renda"], row["_std_renda"])
    renda = int(np.clip(round(renda), 1, 5))
    rendas_num.append(renda)

df_formulario = pd.DataFrame({
    "data_resposta": [gerar_data_range(random.choice([2024, 2025])) for _ in range(n_form)],
    "cpf": df_form_base["cpf"].values,
    "intervalo_renda": [renda_para_texto(r) for r in rendas_num],
    "_renda_num": rendas_num  # para calcular probabilidade de compra
})

print(f"  Total: {len(df_formulario):,} respostas")
print(f"  Distribuição de renda: {pd.Series(rendas_num).value_counts().sort_index().to_dict()}")


# ============================================================
# 3. BASE DE COMPRAS (probabilidade depende da renda)
# ============================================================

print("Gerando base de compras...")

# Para TODOS os leads de interesse, calcular probabilidade de compra
# Quem respondeu formulário: usa renda informada
# Quem não respondeu: usa renda esperada da região (média)

df_interesse_compra = df_interesse.copy()

# Merge com formulário para pegar renda conhecida
df_interesse_compra = df_interesse_compra.merge(
    df_formulario[["cpf", "_renda_num"]],
    on="cpf",
    how="left"
)

# Para quem não respondeu formulário, usar média da região
df_interesse_compra["renda_efetiva"] = df_interesse_compra["_renda_num"].fillna(
    df_interesse_compra["_media_renda"]
)

# Probabilidade de compra baseada na renda
df_interesse_compra["_prob_compra"] = (
    BASE_PROB_COMPRA +
    BONUS_PROB_COMPRA * ((df_interesse_compra["renda_efetiva"] - 1) / 4)
)

# Simular compra
df_interesse_compra["_comprou"] = np.random.binomial(1, df_interesse_compra["_prob_compra"])

df_compradores = df_interesse_compra[df_interesse_compra["_comprou"] == 1].copy()

df_compras = pd.DataFrame({
    "data_compra": [gerar_data_range(random.choice([2024, 2025])) for _ in range(len(df_compradores))],
    "cpf": df_compradores["cpf"].values,
    "destino": np.random.choice(DESTINOS, size=len(df_compradores), p=PESOS_DESTINOS),
    "cep": df_compradores["cep"].values
})

print(f"  Total: {len(df_compras):,} conversões")

# Verificar taxa de conversão por renda (apenas quem respondeu formulário)
df_form_check = df_interesse_compra[df_interesse_compra["_renda_num"].notna()]
taxa_por_renda = df_form_check.groupby("_renda_num").agg(
    taxa_conversao=("_comprou", "mean"),
    n=("cpf", "count")
)
print("\n  Taxa de conversão por faixa de renda (formulário):")
for renda, row in taxa_por_renda.iterrows():
    print(f"    Renda {renda}: {row['taxa_conversao']:.1%} (n={row['n']:,})")


# ============================================================
# 4. EXPORTAR (sem colunas auxiliares)
# ============================================================

print("\nExportando arquivos...")

df_interesse_export = df_interesse[["data_interesse", "cpf", "email", "cep"]].copy()
df_formulario_export = df_formulario[["data_resposta", "cpf", "intervalo_renda"]].copy()
df_compras_export = df_compras[["data_compra", "cpf", "destino", "cep"]].copy()

# Garantir CEP e CPF como string com tamanho correto (preservar zeros à esquerda)
df_interesse_export["cep"] = df_interesse_export["cep"].astype(str).str.zfill(8)
df_interesse_export["cpf"] = df_interesse_export["cpf"].astype(str).str.zfill(11)

df_formulario_export["cpf"] = df_formulario_export["cpf"].astype(str).str.zfill(11)

df_compras_export["cep"] = df_compras_export["cep"].astype(str).str.zfill(8)
df_compras_export["cpf"] = df_compras_export["cpf"].astype(str).str.zfill(11)

df_interesse_export.to_csv("interesse.csv", index=False)
df_formulario_export.to_csv("formulario.csv", index=False)
df_compras_export.to_csv("compras.csv", index=False)

print(f"  interesse.csv:  {len(df_interesse_export):,} linhas")
print(f"  formulario.csv: {len(df_formulario_export):,} linhas")
print(f"  compras.csv:    {len(df_compras_export):,} linhas")


# ============================================================
# 5. VALIDAÇÃO: R² esperado do CEP na predição de renda
# ============================================================

print("\n" + "=" * 50)
print("VALIDAÇÃO DOS DADOS GERADOS")
print("=" * 50)

# Merge para ter CEP e renda juntos
df_check = df_formulario.merge(df_interesse[["cpf", "cep"]], on="cpf")
df_check["cep2"] = df_check["cep"].str[:2]

var_total = df_check["_renda_num"].var()
var_between = df_check.groupby("cep2")["_renda_num"].mean().var()

print(f"Variância total da renda:     {var_total:.3f}")
print(f"Variância entre regiões:      {var_between:.3f}")
print(f"R² (CEP → renda):             {var_between / var_total:.1%}")

# Correlação renda x conversão (na base completa de interesse)
df_check_conv = df_interesse_compra[["renda_efetiva", "_comprou"]].copy()
corr_renda_conv = df_check_conv.corr().iloc[0, 1]
print(f"Correlação renda x conversão: {corr_renda_conv:.3f}")

# Taxa de conversão geral
taxa_geral = df_interesse_compra["_comprou"].mean()
print(f"Taxa de conversão geral:      {taxa_geral:.2%}")

print("\n✓ Dados prontos para testar o modelo de lead scoring!")